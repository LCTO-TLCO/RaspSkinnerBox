---
title: "analyze"
author: "YuTakarada"
date: "2019/4/26"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(entropy)
library(zoo)
library("gridExtra")
setting_data <- NA
all_holes <- c(3,5,7)
```

# データ読み込み
## やってること
- 文字列置換
correct_holes表記がカンマ入りで読み込むときに支障がある
- CSVとしてtxtファイル読み込み
    - data.frameとして変換
```{r read_csv ,echo=FALSE}
header <- c("timestamps","task","session_id","correct_times","event_type","hole_no","add")
#types = c()
#for(r in txt){
#    gsub(":\[(([0-9](, [0-9]){0,1})|None)\],0",)
#}
#behavior_data <- as_tibble(read.csv("../RaspSkinnerBox/log/testlog2.csv",header = F, col.names = header))
#behavior_data <- read_csv('log/cage1_no2.txt', col_names=header, col_types='Tciicic')
behavior_data <- read_csv('../RaspSkinnerBox/log/cage2_no3.txt', col_names=header, col_types='Tciicic')

```

# データ整形
- time out セッションの排除
- collect_hole,incollect_hole の追加
- collect, fail のフラグ追加
- session id ごとのtibble作成
```{r reshape_data , echo=FALSE}
behavior_data %>% filter(str_detect(event_type,"(reward|failure|time over)")) -> dt

## timestamps 
dt$timestamps <- dt$timestamps %>% as.POSIXct()
## task interval
task_start_idx <- c(1)
for (i in 2:nrow(dt)){
  if (dt$task[i] != dt$task[i-1]) {
    task_start_idx[length(task_start_idx)+1] <- c(i)
  }
}

##
dt$hole_correct = ifelse(dt$event_type=='reward', dt$hole_no, 0)
dt$hole_incorrect = ifelse(dt$event_type=='failure', dt$hole_no, 0)
dt$is_correct = ifelse(dt$event_type=='reward', 1, 0)
dt$is_incorrect = ifelse(dt$event_type=='failure', 1, 0)
dt$is_omission = ifelse(dt$event_type=='time over', 1, 0)

dt$cumsum_correct = cumsum(dt$is_correct)
dt$cumsum_incorrect = cumsum(dt$is_incorrect)
dt$cumsum_omission = cumsum(dt$is_omission)

## cumsum

dt$cumsum_correct_taskreset = dt$cumsum_correct
dt$cumsum_incorrect_taskreset = dt$cumsum_incorrect
dt$cumsum_omission_taskreset = dt$cumsum_omission

for (i in 2:length(task_start_idx)){
  idx_st = task_start_idx[i]
  if (i==length(task_start_idx)){
    idx_end = nrow(dt)
  }else{
    idx_end = task_start_idx[i+1] - 1
  }
  dt$cumsum_correct_taskreset[idx_st:idx_end] = dt$cumsum_correct_taskreset[idx_st:idx_end] - dt$cumsum_correct_taskreset[idx_st]
  dt$cumsum_incorrect_taskreset[idx_st:idx_end] = dt$cumsum_incorrect_taskreset[idx_st:idx_end] - dt$cumsum_incorrect_taskreset[idx_st]
  dt$cumsum_omission_taskreset[idx_st:idx_end] = dt$cumsum_omission_taskreset[idx_st:idx_end] - dt$cumsum_omission_taskreset[idx_st]
  
}

dt$is_hole1 = ifelse(dt$hole_no==1, 1,NA)
dt$is_hole3 = ifelse(dt$hole_no==3, 1,NA)
dt$is_hole5 = ifelse(dt$hole_no==5, 1,NA)
dt$is_hole7 = ifelse(dt$hole_no==7, 1,NA)
dt$is_hole9 = ifelse(dt$hole_no==9, 1,NA)

## entropy counting
ent <- function(x){
   return(entropy(discretize(x, numBins=5, r=c(1,9))))
}
he <- rollapply(dt$hole_no,width=150,by=1,FUN=ent)
he <- append(array(0,c(1,length(dt$hole_no)-length(he))), he)
dt$hole_choice_entropy <- he
dt <- transform(dt,index=as.numeric(rownames(dt)))

## burst
dt$burst_group[1] <- 1
for(i in 2:nrow(dt)){
  if(as.numeric(dt$timestamps[i]-dt$timestamps[i-1],units="secs") <= 60){
    dt$burst_group[i] <- dt$burst_group[i-1]
    next
    }
  dt$burst_group[i] <- dt$burst_group[i-1] + 1
}
```

# graph1
```{r graph1 , echo=FALSE,eval=FALSE}
yl <- c(0,max(c(sum(dt$is_incorrect), sum(dt$is_correct) , sum(dt$is_omission))))
cexval <- 0.4
dotcolor <- rgb(0,0,0)

##グラフパラメータを変更する
#グラフパラメータの設定
mai <- par()$mai
#余白サイズの設定(上下と左右の幅を揃える)
mai[4] <- mai[1] 
#指定した余白サイズの適用
par(mai = mai)

plot(dt$cumsum_correct, type="s", ylab="", lty=1, ylim=yl, col=rgb(0,1,0))
par(new=T)
plot(dt$cumsum_incorrect, type="s", lty=2, ylim=yl, col=rgb(1,0,0), axes = F, ann=F)
par(new=T)
plot(dt$cumsum_omission, type="s", lty=2, ylim=yl, col=rgb(0,0,1), axes = F, ann=F)

mtext("cumsum", #2軸目のラベル名
      side = 2, #どこにラベルを置くか(1なら下,2なら左,3なら上,4なら右)
      line = 2 #グラフの枠からの距離
      )

par(new=T)
plot((dt$is_hole1-0.2) * yl[2]*0.5, ylab="", ylim=yl ,col=dotcolor, ann=F, axes = F, cex=cexval)
par(new=T)
plot((dt$is_hole3-0.2) * yl[2]*0.6, ylab="", ylim=yl ,col=dotcolor, ann=F, axes = F, cex=cexval)
par(new=T)
plot((dt$is_hole5-0.2) * yl[2]*0.7, ylab="", ylim=yl ,col=dotcolor, ann=F, axes = F, cex=cexval)
par(new=T)
plot((dt$is_hole7-0.2) * yl[2]*0.8, ylab="", ylim=yl ,col=dotcolor, ann=F, axes = F, cex=cexval)
par(new=T)
plot((dt$is_hole9-0.2) * yl[2]*0.9, ylab="", ylim=yl ,col=dotcolor, ann=F, axes = F, cex=cexval)

for (i in 1:length(task_start_idx)){
  if (i %% 2 == 0){
    if (i+1 > length(task_start_idx)){
      endidx = length(dt$task)
    }else{
      endidx = task_start_idx[i+1]-1
    }
    rect(task_start_idx[i], par()$usr[3], endidx,
         par()$usr[4], col=rgb(1,0,0, alpha=0.1), lty=0)
  }
  text(task_start_idx[i], yl[2], labels=dt$task[task_start_idx[i]], srt=90,adj=c(1,1),cex=0.7)
}

par(new=T)
plot(dt$hole_choice_entropy, type="s", ylab="", ann=F, axes = F)
axis(4)
mtext("Entropy (bit)", #2軸目のラベル名
      side = 4, #どこにラベルを置くか(1なら下,2なら左,3なら上,4なら右)
      line = 2 #グラフの枠からの距離
      )

```

# graph2
```{r graph2 , echo=FALSE}
yl <- c(0,max(c(dt$cumsum_correct_taskreset, dt$cumsum_incorrect_taskreset, dt$cumsum_omission_taskreset  ))*1.3 )
gg = function(p) ggplot_gtable(ggplot_build(p))
cexval <- 0.4
dotcolor <- rgb(0,0,0)
par(mai = mai)

# task start
graph <- ggplot()
task_index <- data.frame(xmin=task_start_idx,
                         xmax=c(task_start_idx[-1]-1,nrow(dt)),
                         task = dt$task[task_start_idx])
odd <- seq(1, nrow(task_index), by = 2)
odd_flag <- odd
odd_flag[odd_flag>=1]<- 1
graph <- graph +   
  geom_rect(data = task_index[odd,], aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf,fill=odd_flag),alpha=0.3)+  
  # geom_text(data = task_index,aes(x=xmin+50, y=yl[2]*0.8, label=task),srt=90,adj=1)+
  guides(fill=FALSE)
graph


# cumsum
cumsum_graph <- graph +
  geom_line(data=dt,aes(x=index,y=cumsum_correct_taskreset,colour="correct"))+
  geom_line(data=dt,aes(x=index,y=cumsum_incorrect_taskreset,colour="incorrect"))+
  geom_line(data=dt,aes(x=index,y=cumsum_omission_taskreset,colour="omission"))+
  xlab("index")+
  ylab("cumsum per task")+
  theme(plot.margin = unit(c(0,0,0,0),"lines"),
        legend.position = c(0.5, 0.9),
        legend.direction = "horizontal"
        )+
scale_colour_manual(
    values = c(
      correct  = "green",
      incorrect  = "red",
      omission  = "blue"
    )
  )
cumsum_graph

# hole dot

hole_dot_graph <- graph +
  geom_point(data=dt,aes(y=(is_hole1)*1,x=index,colour=dotcolor))+
  geom_point(data=dt,aes(y=(is_hole3)*2,x=index,colour=dotcolor))+
  geom_point(data=dt,aes(y=(is_hole5)*3,x=index,colour=dotcolor))+
  geom_point(data=dt,aes(y=(is_hole7)*4,x=index,colour=dotcolor))+
  geom_point(data=dt,aes(y=(is_hole9)*5,x=index,colour=dotcolor))+
  guides(colour=FALSE)+
  xlab("")+
  ylab("hole dots")+
  theme(axis.text.x = element_blank(),
        plot.margin = unit(c(0,0,0,0),"lines"),
        axis.ticks.x = element_blank())
hole_dot_graph


# plot((dt$is_hole9-0.2) * yl[2]*0.6, ylab="", ylim=yl ,col=dotcolor, ann=F, cex=cexval, axes = F)

# entropy
entropy_graph <- ggplot()+  
  geom_rect(data = task_index[odd,], aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf,fill=odd_flag),alpha=0.3)+  
  geom_text(data = task_index,aes(x=xmin+50, y=max(dt$hole_choice_entropy), label=task),srt=90,adj=1)+
  guides(fill=FALSE)+
  geom_line(data=dt,aes(x=index,y=hole_choice_entropy))+
  xlab("")+
  ylab("Entropy (bit)")+
  theme(plot.margin = unit(c(0,0,0,0),"lines"),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
entropy_graph
# plot(dt$hole_choice_entropy, type="s", ylab="", ylim=c(-3,3), ann=F, axes = F)
# grid.arrange(entropy_graph,hole_dot_graph,cumsum_graph,ncol=1)
# http://sakananoiroiro.seesaa.net/article/460806470.html
# 今動く方
g1 <- ggplot_gtable(ggplot_build(entropy_graph))
g2 <- ggplot_gtable(ggplot_build(hole_dot_graph))
g3 <- ggplot_gtable(ggplot_build(cumsum_graph))
gnew <- gtable_rbind(g1, g2,g3, size="first")
plot(gnew)
ggsave("graphs.eps",gnew,dpi = 300,width = 9,height = 6)


# テスト中
# test_cumsum_graph <- graph +
#   geom_line(data=dt,aes(x=index,y=cumsum_correct_taskreset,colour="correct"))+
#   geom_line(data=dt,aes(x=index,y=cumsum_incorrect_taskreset,colour="incorrect"))+
#   geom_line(data=dt,aes(x=index,y=cumsum_omission_taskreset,colour="omission"))+
#   xlab("index")+
#   ylab("cumsum per task")+
#   theme(plot.margin = unit(c(0,0,0,0),"lines"))
# t1 <- gg(entropy_graph)
# t2 <- gg(hole_dot_graph)
# t3 <- gg(test_cumsum_graph)
# tL <- t3[3,] # 凡例だけ取り出す
# t3 <- t3[-3,] # 凡例を削除
# tnew <- gtable_rbind(t1, t2, t3)
# plot(tnew)
# 
# a1 <- ggplotGrob(entropy_graph)
# a2 <- ggplotGrob(hole_dot_graph)
# a3 <- ggplotGrob(test_cumsum_graph)
# legend_a3 <- a3[["grobs"]][[grep("guide-box", a3$layout$name)]]
# a3[["grobs"]][[grep("guide-box", a3$layout$name)]]
# anew <- gtable_rbind(a1, a2, a3)


```
# モデル比較
## model 定義
### dth-order markov model
dtにモデルごとの選択確率を追加

```{r malcov eval=FALSE}
func_markov <- function(datas,dem,dummy){
  header <- c("hole1","hole2","hole3","hole4","hole5")
  # probability <- data.frame(matrix(rep(NA, 5), nrow=1))[numeric(0), ]
  # colnames(probability) <- header
  probability <- c()
  ids <- datas %>%
  filter(event_type == "reward"|event_type=="failure") %>%
  select(session_id) %>%
  unique() %>%
  order()
  for(t in ids){
    # 分析対象の抽出
    target_data <- datas %>%
    filter(grepl(session_id,ids,session_id<=t))
    if(dth < length(target_data)){
      target_data <- targetdata[length(target_data)-dem:length(target_data)]
    }
    prob <- c()
    for (number in order(unique(data$hole_no))){
      prob <- append(retval,(length(d[[d$hole_no==number]]+1))/(length(d)+2))
    }
    probability <- probability %>%
      rbind(prob)
  }
  return(data.frame(mc_hole1=probability[1],mc_hole2=probability[2],
                    mc_hole3=probability[3],mc_hole4=probability[4],
                    mc_hole5=probability[5]))
}
```

### Q-Learning
```{r Q-learning}
# param にはパラメータを指定
# 2*2
# standard :alpha[2]=kappa[2]=0
# forgetting: alpha[1]=alpha[2]
# Diff F: all free params
func_QL <- function(datas,param,param_type){
  # 定義
  ids <- datas %>%
    filter(event_type == "reward"|event_type=="failure") %>%
    select(session_id) %>%
    unique() %>%
    order()
  holes <-unique(datas$hole_no)
  Q = matrix(numeric(length(holes)*length(datas)), nrow=length(holes), ncol = length(datas))
  Q[1] <- param$Q1
  ll <- 0
  probability <- c()
  # パラメータ定義
  if(param_type=="F"){
    param$alpha2=param$alpha1
  }else if(param_type=="standard"){
    param$alpha2 <- param$kappa2 <- 0
  }
  # 選択されたhole に対応したQ値更新
  for(t in ids){
    target_data <- datas %>%
      filter(grepl(session_id,ids,session_id<=t))
    last_reward <- target_data %>%
      filter(event_type=="reward"|event_type=="failure"|session_id==t)
    last_selection <- target_data %>%
      filter(event_type=="nose poke"|session_id==t)
    for(hole in holes){
      learning_late <- 1 - param$alpha[1]
      disgust <- param$alpha[1] * param$kappa[1]
      if(last_selection$hole_no==t|last_reward$event_type=="failure"){
        disgust <- (-1)*param$alpha[1] * param$kappa[2]        
      }else if(last_selection$hole_no==!t){
        learning_late <- 1 - param$alpha[2]
      }
      Q[which(ids==t)+1,which(holes==hole)] <- learning_late*Q[which(holes==hole),which(ids==t)] + disgust
    }
    #TODO 代入  
    rbind(probability,action_prob(Q[which(ids==t)+1,]))
  }
  # 全holeの選択確率を更新
   
  return(data.frame(hole1=probability[1],hole2=probability[2],
                  hole3=probability[3],hole4=probability[4],
                  hole5=probability[5]))

}
action_prob <- function(Qvalues){
  return(Qvalues/sum(Qvalues))
  
}
```

# 尤度関数
```{r least_sm}
least_sm <- function(param,data,func,param_type){
    prob <- func(data,param,param_type)
    hole_flag <- dt %>%
      select(starts_with("is_hole"))
    # 実データで取った行動のモデル側の確率のみを抽出する
    return((prob*hole_flag))
}
```

```{r model_fitting}
#TODO 
optim(c(10, 2), loglikelihood, y = y)
```

# TODO
# 0. ggplot2化 (graph1は不要)
# 1. hole dot表示とentropyを同横軸別グラフ縦に並べる
# 2. PNG解像度を上げる(このままだとpptに貼れない)
# 3. eps出力
## ggsave で eps 指定可能
## 手動出力時指定可能

# 4. correctの増加はomissionの低下とパラレル

# やっていること
## 

```

